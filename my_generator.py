import numpy as np
import my_bbox_tool as bt
from Utils.nms.non_maximum_suppression import  non_maximum_suppression
import cupy as cp

def anchor_generator(anchor_base,img_height,img_widht,feat_stride):
    """
    use base anchor to genrate anchors for whole img(in origin size scale)
    :param anchor_base: base anchor
    :param img_height:
    :param img_widht:
    :param feat_stride:
    :return:
    """
    shift_x = np.arange(0,img_widht * feat_stride,feat_stride)
    shift_y = np.arange(0,img_height * feat_stride,feat_stride)

    shift_x,shift_y = np.meshgrid(shift_x,shift_y)

    shift = np.stack((shift_y.ravel(),shift_x.ravel(),shift_y.ravel(),shift_x.ravel()),axis = 1 )

    n_baseanchor = anchor_base.shape[0]
    n_anchor = shift.shape[0]

    #anchor_base(K,4) shift(N,4),相加应该要  1，K，4 和 N，1，4，才能达到想要的广播,出来以后应该是(N,K,4)
    anchor = anchor_base.reshape(1,n_anchor,4) + shift.reshape(n_anchor,1,4)

    anchor = anchor.reshape(n_anchor*n_baseanchor,4).astype(np.float32)
    return anchor

class Anchortarget_generator:
    def __init__(self,n_sample = 256, positive_ratio = 0.5,
                 pos_thresh = 0.7, neg_thresh = 0.3):
        self.n_sample = n_sample
        self.positive_ratio = positive_ratio,
        self.pos_thresh = pos_thresh
        self.neg_thresh = neg_thresh

    def __call__(self,gt_bbox,rpn_anchor,img_size):
        #output anchortarget, return 2 arrays, one is loc(n_sample,4) and one is label(n_sample,)
        #输出anchortarget，return2个array，一个是loc，一个是label，分别是(n_sample,4),(n_sample,)
        H,W = img_size

        n_anchor = len(rpn_anchor)
        inside_index = bt.get_inside_index(rpn_anchor,H,W)
        anchor = rpn_anchor[inside_index,:]


        argmax_ious, label = self._create_label(anchor,gt_bbox)

        loc = bt.bbox2loc(anchor,gt_bbox[0,argmax_ious])
        #loc output from RPN is N,36,H,W. It's like every anchor on every pixel need to learn offset to do loss,so we need to remap it to the original size of anchor. same for label.
        #RPN的loc输出是N，36，H，W，相当于每个点的anchor都要学偏移量来做loss，所以要remap回原来anchor的大小，label同理
        label = bt.unmap(label, n_anchor, inside_index, fill=-1)
        loc = bt.unmap(loc, n_anchor, inside_index, fill=0)

        return loc,label

    def _iou_calc(self,anchor,bbox):
        iou = bt.bbox_iou(anchor,bbox)
        argmax_ious = np.argmax(iou,axis = 1 )
        max_ious = iou[np.arange(iou.shape[0]),argmax_ious]
        gt_argmax_ious = np.argmax(iou,axis = 0)
        gt_max_ious = iou[gt_argmax_ious,np.arange(iou.shape[1])]


        return argmax_ious, max_ious, gt_argmax_ious


    def _create_label(self,anchor,bbox):
        label = np.empty((anchor.shape[0],),dtype= np.int32)
        label.fill(-1)
        argmax_ious, max_ious, gt_argmax_ious = self._iou_calc(anchor, bbox)

        label[max_ious < self.neg_thresh] = 0

        label[max_ious >= self.pos_thresh] = 1

        label[gt_argmax_ious] = 1
        #sampling some of the positive samples, maybe too much, so random. 
        #采样一部分正样本，因为可能太多了,真是随机采样啊。。
        #no idea why positive_ratio is a tuple
        #我也不知道为什么positive_ratio会是个tuple
        n_positive = self.n_sample *self.positive_ratio[0]
        n_positive = int(n_positive)
        #返回tuple，第一个tuple全是行索引
        pos_index = np.where(label == 1)[0]
        if len(pos_index) > n_positive:
            disable_index = np.random.choice(pos_index,len(pos_index) - n_positive,replace=False)
            label[disable_index] = -1

        # subsample negative labels if we have too many
        n_neg = self.n_sample - np.sum(label == 1)
        neg_index = np.where(label == 0)[0]
        if len(neg_index) > n_neg:
            disable_index = np.random.choice(
                neg_index, size=(len(neg_index) - n_neg), replace=False)
            label[disable_index] = -1

        return argmax_ious,label


class ProposalCreator:
    """Proposal regions are generated by calling this object.
    use loc from RPN to refine 20000 initial anchor. Then crop these rois according the original image size.
    Then record indexes of all rois which has both width and height larger than 16.
    Say we got 18000 boxes, then use score to descending sort these rois, select top 12000. fianlly use nms, get 2000 rois.
    用RPN的2路输出的loc，对20000个初始anchor进行微调。然后根据原图尺寸将这些rois进行截断
    在原图像大小内部。然后将此时所有roi中所有宽与高皆大于16的roi的索引记录，假设有18000个roi满足。
    然后利用预测值score对这些roi从高到低排序，只取前12000个。然后利用NMS进一步筛选，得到2000个roi。
    Args:
        nms_thresh (float): Threshold value used when calling NMS.
        min_size (int): A paramter to determine the threshold on
            discarding bounding boxes based on their sizes.
    """
    def __init__(self,
                 img_size, n_pre_nms, n_post_nms,
                 anchor,
                 nms_thresh = 0.7,
                 min_size = 16
                ):
        self.nms_thresh = nms_thresh
        self.min_size = min_size
        self.img_size = img_size
        self.n_pre_nms = n_pre_nms
        self.n_post_nms = n_post_nms
        self.anchor = anchor
    def __call__(self,loc,score,scale = 1.):
        """input should  be ndarray
        Propose RoIs
        input origianl pic size, scale, 20000 rois, loc and score from rpn
        输入原图尺寸，scale，20000个roi，rpn输出的loc和score，

        """

        #Convert anchors into propasla via bbox transoform
        roi = bt.loc2bbox(self.anchor,loc)

        #clip predicted boxed to image，在原图尺寸内截断,slice(0,4,2)就是取了(0,2)，clip就是限制在0到图片尺寸之间
        roi[:,slice(0,4,2)] = np.clip(roi[:,slice(0,4,2)],0,self.img_size[0])
        roi[:,slice(1,4,2)] = np.clip(roi[:,slice(1,4,2)],0,self.img_size[1])

        #Remove predicted boxed with either height or width < threshold
        height = roi[:,2] - roi[:,0]
        width = roi[:,3] - roi[:,1]
        #use where to find row-index,用where找行索引
        self.min_size = self.min_size * scale
        keep_index = np.where((height >= self.min_size) & (width >= self.min_size))[0]
        roi = roi[keep_index,:]
        score = score[keep_index]



        #argsort函数返回的是数组值从小到大的索引值.[::-1]相当于步长-1，也就是从大到小的排
        order_index = score.ravel().argsort()[::-1]
        order_index = order_index[:self.n_pre_nms]#先选出前N个来
        roi = roi[order_index,:]


        # Apply nms (e.g. threshold = 0.7).
        # Take after_nms_topN,nms返回来一个array，是选出来的框的index，然后是按score降序排的
        #nms return an array, includes the index of selected boxes, then descending sorted by score 
        keep = non_maximum_suppression(
            cp.ascontiguousarray(cp.asarray(roi)),
            thresh=self.nms_thresh)
        keep = keep[:self.n_post_nms]
        roi = roi[keep]
        return roi

class ProposalTargetCreator:
    """
    Assign gt bbox to given rois.
    Args:
        n_sample(int) : The number of sampled regions.
        pos_ratio(float): Fraction of regions that is labeled as a foreground.
        pos_iou_thresh(float):IoU threshold for a RoI.
        neg_iou_thresh_hi(float):
        neg_iou_thresh_io(float):
    """
    def __init__(self,
                 n_sample = 128,
                 pos_ratio = 0.25,
                 pos_iou_thresh = 0.5,
                 neg_iou_thresh_hi = 0.5,
                 neg_iou_thresh_io = 0.0):
        self.n_sample = n_sample
        self.pos_ratio = pos_ratio
        self.pos_iou_thresh = pos_iou_thresh
        self.neg_iou_thresh_hi = neg_iou_thresh_hi
        self.neg_iou_thresh_io = neg_iou_thresh_io

    def __call__(self,roi,bbox,label,
                 loc_normalize_mean=(0., 0., 0., 0.,),
                 loc_normalize_std=(0.1, 0.1, 0.2, 0.2)):
        """
        Assign gt to sampled proposals.
        输入一张图像中的gt bbox和label，输入propasalcreator输出的roi，做一次采样筛选，
        输出的bbox和label给到RoIHEAD作gt

        """

        roi = np.concatenate((roi,bbox[0,:,:]),axis= 0)

        n_roi_per_img = np.round(self.n_sample * self.pos_ratio)#每张图的toi数量
        iou = bt.bbox_iou(roi,bbox)
        #select label in need
        #选出需要的label
        label = label[0]
        gt_asn = iou.argmax(axis = 1)#每个框对应的gt label的索引
        roi_label = label[gt_asn] + 1  #+1是为了range of classes from [0, n_fg_class - 1] to [1, n_fg_class]，The label with value 0 is the background.

        #选出需要的roi，即该roi的最大iou得大于阈值
        max_iou = iou.max(axis = 1)
        pos_index = np.where(max_iou >= self.pos_iou_thresh)[0]

        # 这张图实际可以有的roi的数量，一般和固定的不会有差，但是以防万一
        n_roi_this_img = int(min(n_roi_per_img,pos_index.size))
        if n_roi_this_img > 0:   #如果有保留下来的框，随机选取这张图需要的数量的框
            pos_index = np.random.choice(pos_index,size = n_roi_this_img,replace=False)
        #select background roi
        #选出背景roi
        neg_index = np.where((max_iou < self.neg_iou_thresh_hi) &
                             (max_iou >= self.neg_iou_thresh_io))[0]  # 拿出最大iou小于neg阈值的行索引
        neg_roi_per_this_image = self.n_sample - n_roi_this_img
        neg_roi_per_this_image = int(min(neg_roi_per_this_image, neg_index.size))

        if neg_index.size > 0:
            neg_index = np.random.choice(
                neg_index,size = neg_roi_per_this_image, replace= False
            )

        # The indices that we're selecting (both positive and negative).
        keep_index = np.append(pos_index,neg_index)#新建一个array，按顺序存pos和neg的index
        roi_label = roi_label[keep_index]#roilabel本身的维度是(所有roi的数量，1),从中选取保留了的roi的label
        roi_label[n_roi_this_img:] = 0 #negative labels --> 0
        sample_roi = roi[keep_index] #采样的roi, sampling roi
        #after roi, calculate loc
        #roi出来以后，就得进行loc的计算,roi和gt的loc偏移量
        roi_loc = bt.bbox2loc(sample_roi,bbox[0,gt_asn[keep_index]])
        #standardized for convergence. need to restore it when predicting
        #做了标准化，方便收敛，最后predict的时候，roiloc需要乘回去
        roi_loc = ((roi_loc - np.array(loc_normalize_mean, np.float32))
                     / np.array(loc_normalize_std, np.float32))


        return sample_roi,roi_loc,roi_label


# class anchortargetgenerator():
#     def __init__(self,n_sample = 256,
#                  pos_ratio = 0.5,pos_thresh = 0.7,
#                  neg_thresh = 0.3):
#         self.n_sample = 256
#         self.pos_ratio = pos_ratio
#         self.pos_thresh = pos_thresh
#         self.neg_thresh = neg_thresh
#
#     def __call__(self,rpn_anchor,bbox,img_size):
#
#         H,W = img_size
#         inside_index = bt.get_inside_index(rpn_anchor,H,W)
#         anchor = rpn_anchor[inside_index,:]
#
#     def _calc_iou(self,anchor,bbox):
#         iou = bt.bbox_iou(anchor,bbox)
#         argmax_iou = np.argmax(iou,axis = 1)




    # def _create_label(self,):
